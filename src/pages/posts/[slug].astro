---
import BaseLayout from '../../layouts/BaseLayout.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import Pills from '../../components/Pills.astro';
import { getPostBySlug, getPosts, getFeatured, getAuthor } from '../../data/wp.ts';
import sanitizeHtml from 'sanitize-html';
import CalendarIcon from '../../assets/images/icon-calendar.svg';
import ClockIcon from '../../assets/images/icon-clock.svg';

// Generate static paths for all posts
export async function getStaticPaths() {
  try {
    // First try to get posts from the API
    let allPosts: any[] = [];
    
    try {
      const { items: posts } = await getPosts({ page: 1, perPage: 100 });
      allPosts = posts;
    } catch (apiError) {
      // Fallback: try to get individual posts by known slugs
      const knownSlugs = [
        'rethinking-mfa-what-happens-when-the-user-sends-the-code',
        'the-linux-designer',
        'the-psychology-of-the-web',
        'the-future-of-user-authentication-biometrics-vs-passkeys',
        'the-importance-of-digital-product-design',
        'transitioning-from-cloud-hosting-to-self-hosting',
        'my-home-network-from-anywhere-with-openvpn',
        'making-animations-for-the-web-with-lottie',
        'moderating-user-generated-content',
        'change-by-design-key-takeaways'
      ];
      
      for (const slug of knownSlugs) {
        try {
          const post = await getPostBySlug(slug);
          if (post) {
            allPosts.push(post);
          }
        } catch (error) {
          console.error(`❌ Failed to fetch post: ${slug}`, error);
        }
      }
    }
    
    if (allPosts.length === 0) {
      return [];
    }
    
    const paths = allPosts.map(post => {
      return {
        params: { slug: post.slug },
        props: { post }
      };
    });

    return paths;  } catch (error) {
    console.error('❌ Error generating static paths:', error);
    return [];
  }
}

const { post } = Astro.props;

if (!post) {
  console.error('❌ No post data available');
  return Astro.redirect('/404');
}
if (!post.title?.rendered) {
  console.error(`❌ Post ${post.slug} missing title`);
}
if (!post.content?.rendered) {
  console.error(`❌ Post ${post.slug} missing content`);
}
if (!post.date) {
  console.error(`❌ Post ${post.slug} missing date`);
}

// Function to strip HTML tags for meta description
function stripHtml(html: string): string {
  return html.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, ' ').trim();
}

// Function to calculate read time
function calculateReadTime(content: string): string {
  const wordCount = stripHtml(content).split(/\s+/).length;
  const readTime = Math.ceil(wordCount / 200); // 200 words per minute
  return `${readTime} min`;
}

// Sanitize HTML content
function sanitizeContent(html: string): string {
  return sanitizeHtml(html, {
    allowedTags: ['p', 'h1', 'h2', 'h3', 'h4', 'a', 'img', 'ul', 'ol', 'li', 'pre', 'code', 'blockquote', 'hr', 'strong', 'em', 'br', 'figure', 'figcaption', 'div', 'iframe'],
    allowedAttributes: {
      'a': ['href', 'target', 'rel'],
      'img': ['src', 'alt', 'loading', 'decoding', 'width', 'height', 'class', 'data-caption', 'title'],
      'figure': ['class'],
      'figcaption': ['class', 'role'],
      'div': ['class'],
      'iframe': ['src', 'width', 'height', 'frameborder', 'allow', 'allowfullscreen', 'loading', 'title', 'referrerpolicy']
    },
    allowedSchemes: ['http', 'https', 'mailto'],
    allowedClasses: {
      'figure': ['wp-block-image', 'wp-caption', 'media-figure', 'wp-block-embed', 'is-type-video', 'is-provider-youtube', 'wp-block-embed-youtube', 'wp-embed-aspect-16-9', 'wp-has-aspect-ratio'],
      'figcaption': ['wp-element-caption', 'media-caption', 'figure-caption', 'mb-2'],
      'div': ['wp-caption-text', 'media-box', 'wp-block-embed__wrapper'],
      'img': ['img-fluid', 'd-block', 'my-1']
    },
    transformTags: {
      'img': function(tagName: string, attribs: any) {
        return {
          tagName: 'img',
          attribs: {
            ...attribs,
            loading: 'lazy',
            decoding: 'async',
            class: 'img-fluid d-block my-1'
          }
        };
      }
    }
  });
}

// Transform WordPress figure markup to exact media-figure system
function transformMediaFigures(html: string): string {
  let result = html;
  
  // Transform WordPress figures to media-figure system
  result = result.replace(
    /<figure class="wp-block-image[^"]*"([^>]*)>(.*?)<\/figure>/gs,
    (match, figureAttribs, content) => {
      // Extract image and figcaption separately
      const imgMatch = content.match(/<img([^>]*)>/);
      const figcaptionMatch = content.match(/<figcaption[^>]*>(.*?)<\/figcaption>/s);
      
      if (!imgMatch) return match; // No image found, return original
      
      const imgAttribs = imgMatch[1];
      let figcaptionContent = '';
      
      if (figcaptionMatch) {
        figcaptionContent = `<figcaption class="media-caption figure-caption mb-2" role="note">${figcaptionMatch[1]}</figcaption>`;
      } else {
        // Check if image has data-caption or title attribute for auto-caption
        const dataCaptionMatch = imgAttribs.match(/data-caption="([^"]*)"/);
        const titleMatch = imgAttribs.match(/title="([^"]*)"/);
        
        if (dataCaptionMatch) {
          figcaptionContent = `<figcaption class="media-caption figure-caption mb-2" role="note">${dataCaptionMatch[1]}</figcaption>`;
        } else if (titleMatch) {
          figcaptionContent = `<figcaption class="media-caption figure-caption mb-2" role="note">${titleMatch[1]}</figcaption>`;
        }
      }
      
      return `<figure class="media-figure">
  <div class="media-box">
    <img class="img-fluid d-block my-1"${imgAttribs}>
    ${figcaptionContent}
  </div>
</figure>`;
    }
  );
  
  // Handle standalone images (not in figures) that have captions
  result = result.replace(
    /<img([^>]*(?:data-caption|title)="[^"]*"[^>]*)>/g,
    (match, imgAttribs) => {
      const dataCaptionMatch = imgAttribs.match(/data-caption="([^"]*)"/);
      const titleMatch = imgAttribs.match(/title="([^"]*)"/);
      
      let captionText = '';
      if (dataCaptionMatch) {
        captionText = dataCaptionMatch[1];
      } else if (titleMatch) {
        captionText = titleMatch[1];
      }
      
      if (captionText) {
        return `<figure class="media-figure">
  <div class="media-box">
    <img class="img-fluid d-block my-1"${imgAttribs}>
    <figcaption class="media-caption figure-caption mb-2" role="note">${captionText}</figcaption>
  </div>
</figure>`;
      }
      
      return match;
    }
  );
  
  return result;
}

// Transform internal WordPress links to Astro routes
function transformInternalLinks(html: string): string {
  // Transform links from WordPress domain to Astro /posts/ structure
  // This regex matches various formats of nico.ar domain links
  let result = html;
  
  // Match: https://www.nico.ar/slug/ or https://www.nico.ar/slug
  result = result.replace(
    /(<a[^>]+href=")https:\/\/www\.nico\.ar\/([^\/"\s]+)\/?("[^>]*>)/g,
    '$1/posts/$2$3'
  );
  
  // Match: https://nico.ar/slug/ or https://nico.ar/slug (without www)
  result = result.replace(
    /(<a[^>]+href=")https:\/\/nico\.ar\/([^\/"\s]+)\/?("[^>]*>)/g,
    '$1/posts/$2$3'
  );
  
  // Match: www.nico.ar/slug (without protocol)
  result = result.replace(
    /(<a[^>]+href=")www\.nico\.ar\/([^\/"\s]+)\/?("[^>]*>)/g,
    '$1/posts/$2$3'
  );
  
  return result;
}

// Transform YouTube embeds into media-figure structure
function transformYouTubeEmbeds(html: string): string {
  let result = html;
  
  // Match WordPress YouTube embed figures: <figure class="wp-block-embed..."><div class="wp-block-embed__wrapper"><iframe...></iframe></div><figcaption>...</figcaption></figure>
  result = result.replace(
    /<figure class="wp-block-embed[^"]*"[^>]*>(.*?)<\/figure>/gs,
    (match, content) => {
      // Check if this is a YouTube embed
      if (!content.includes('youtube.com/embed')) {
        return match; // Not a YouTube embed, return original
      }
      
      // Extract iframe
      const iframeMatch = content.match(/<iframe([^>]*)><\/iframe>/);
      if (!iframeMatch) return match;
      
      const iframeAttribs = iframeMatch[1];
      
      // Extract figcaption if present (this is the real caption, not the title attribute)
      const figcaptionMatch = content.match(/<figcaption[^>]*>(.*?)<\/figcaption>/s);
      let figcaptionContent = '';
      
      if (figcaptionMatch) {
        figcaptionContent = `<figcaption class="media-caption figure-caption mb-2" role="note">${figcaptionMatch[1]}</figcaption>`;
      }
      
      // Remove title attribute from iframe as it's for screen readers, not display
      const cleanedIframeAttribs = iframeAttribs.replace(/\s*title="[^"]*"/g, '');
      
      // Build the media-figure structure matching images
      return `<figure class="media-figure">
  <div class="media-box">
    <iframe class="img-fluid d-block my-1"${cleanedIframeAttribs}></iframe>
    ${figcaptionContent}
  </div>
</figure>`;
    }
  );
  
  return result;
}

// Get categories from embedded data
const categories = post._embedded?.['wp:term']?.[0] || [];

// Get author name and featured image using helper functions
const authorName = getAuthor(post);
const featuredImage = getFeatured(post);

// Format date
const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
};

const metaDescription = stripHtml(post.excerpt.rendered).substring(0, 160);

// Safely transform content with error handling
let sanitizedContent: string;
try {
  const cleanContent = sanitizeContent(post.content.rendered);
  // Transform internal links first, then media figures, then YouTube embeds
  const linkedContent = transformInternalLinks(cleanContent);
  const mediaContent = transformMediaFigures(linkedContent);
  sanitizedContent = transformYouTubeEmbeds(mediaContent);
} catch (error) {
  console.error(`❌ Error processing content for post ${post.slug}:`, error);
  // Fallback to basic sanitized content without transformations
  sanitizedContent = sanitizeContent(post.content.rendered);
}
---

<BaseLayout 
  title={`${post.title.rendered} - nico.ar`} 
  description={metaDescription}
  image={featuredImage.src || "/og.jpg"}
>
  <Header slot="header" />
  
  <article class="section pt-2 pt-md-4">
    <!-- Back to Articles link -->
    <div class="back-to-articles pb-1 mb-2">
      <a href="/" class="back-link" id="back-to-articles">
        <span class="back-arrow">←</span> Back to Articles
      </a>
    </div>

    <!-- Featured image -->
    {featuredImage.src ? (
      <div class="article-hero-wrapper pb-2 mb-3">
        <img 
          src={featuredImage.src} 
          alt={featuredImage.alt || post.title.rendered}
          class="article-hero"
          loading="lazy"
          decoding="async"
        />
      </div>
    ) : (
      <div class="article-hero--placeholder"></div>
    )}
    
    <!-- Categories -->
    {categories.length > 0 && (
      <div class="article-pills mb-2 mb-sm-3">
        <Pills tags={categories} />
      </div>
    )}
    
    <!-- Article title -->
    <h1 class="article-title mt-0">{post.title.rendered}</h1>
    
    <!-- Meta information -->
    <div class="article-meta article-meta pb-2 mb-3 pb-sm-3 mb-sm-4">
      <div class="meta-item">
        <img src={CalendarIcon.src} alt="" width="16" height="16" />
        <span>{formatDate(post.date)}</span>
      </div>
      <div class="meta-item">
        <img src={ClockIcon.src} alt="" width="16" height="16" />
        <span>{calculateReadTime(post.content.rendered)}</span>
      </div>
    </div>
    
    <!-- Article content -->
    <div class="article-content" set:html={sanitizedContent} />
  </article>
  
  <!-- DOM script to inject figcaptions and handle smart navigation -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Inject figcaptions for images that have data-caption or title attributes
      const mediaFigures = document.querySelectorAll('.media-figure .media-box');
      
      mediaFigures.forEach(mediaBox => {
        const img = mediaBox.querySelector('img');
        const existingCaption = mediaBox.querySelector('figcaption');
        
        if (img && !existingCaption) {
          const captionText = img.getAttribute('data-caption') || img.getAttribute('title') || img.getAttribute('alt');
          
          if (captionText && captionText.trim() !== '') {
            const figcaption = document.createElement('figcaption');
            figcaption.className = 'media-caption figure-caption mb-2';
            figcaption.setAttribute('role', 'note');
            figcaption.textContent = captionText.trim();
            img.insertAdjacentElement('afterend', figcaption);
          }
        }
      });
      
      // Smart back navigation using sessionStorage
      const backLink = document.getElementById('back-to-articles');
      if (backLink) {
        const returnPage = sessionStorage.getItem('blog-return-page');
        if (returnPage) {
          backLink.setAttribute('href', returnPage);
          sessionStorage.removeItem('blog-return-page');
        }
      }
    });
  </script>
  
  <Footer slot="footer" />
</BaseLayout>
